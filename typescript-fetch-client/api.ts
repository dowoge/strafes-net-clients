/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * StrafesNET Public API
 * ### How to use To request an api key open a support request in the [issue tracker](https://issues.strafes.net/client/index.php#/types/3/issues).  ### Default API request rate limits are as follows * 100 requests per minute * 3000 requests per hour  ### Game IDs ``` 1 Bhop 2 Surf ``` ### Style IDs ``` 1 Autohop 2 Scroll 3 Sideways 4 Half-Sideways 5 W-Only 6 A-Only 7 Backwards ``` 
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://api.strafes.net/v1".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * 
     * @type {number}
     * @memberof ApiError
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    reference?: string;
}

/**
 * 
 * @export
 * @interface ModelMap
 */
export interface ModelMap {
    /**
     * 
     * @type {number}
     * @memberof ModelMap
     */
    ID?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelMap
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelMap
     */
    creator?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelMap
     */
    game?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelMap
     */
    date?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelMap
     */
    playCount?: number;
}

/**
 * 
 * @export
 * @interface Rank
 */
export interface Rank {
    /**
     * 
     * @type {number}
     * @memberof Rank
     */
    ID?: number;
    /**
     * 
     * @type {number}
     * @memberof Rank
     */
    user?: number;
    /**
     * 
     * @type {number}
     * @memberof Rank
     */
    style?: number;
    /**
     * 
     * @type {number}
     * @memberof Rank
     */
    mode?: number;
    /**
     * 
     * @type {number}
     * @memberof Rank
     */
    game?: number;
    /**
     * 
     * @type {number}
     * @memberof Rank
     */
    rank?: number;
    /**
     * 
     * @type {number}
     * @memberof Rank
     */
    skill?: number;
    /**
     * 
     * @type {number}
     * @memberof Rank
     */
    placement?: number;
}

/**
 * If a new time is made it will retain the previous time's id.
 * @export
 * @interface Time
 */
export interface Time {
    /**
     * 
     * @type {number}
     * @memberof Time
     */
    ID?: number;
    /**
     * 
     * @type {number}
     * @memberof Time
     */
    time?: number;
    /**
     * 
     * @type {number}
     * @memberof Time
     */
    user?: number;
    /**
     * 
     * @type {number}
     * @memberof Time
     */
    map?: number;
    /**
     * 
     * @type {number}
     * @memberof Time
     */
    date?: number;
    /**
     * 
     * @type {number}
     * @memberof Time
     */
    style?: number;
    /**
     * 
     * @type {number}
     * @memberof Time
     */
    mode?: number;
    /**
     * 
     * @type {number}
     * @memberof Time
     */
    game?: number;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    ID?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    username?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    state?: number;
}


/**
 * MapApi - fetch parameter creator
 * @export
 */
export const MapApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get list of maps.
         * @param {number} [game] Game ID filter
         * @param {number} [page] Page api results. Page size is 200.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mapGet(game?: number, page?: number, options: any = {}): FetchArgs {
            const localVarPath = `/map`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api-key")
					: configuration.apiKey;
                localVarHeaderParameter["api-key"] = localVarApiKeyValue;
            }

            if (game !== undefined) {
                localVarQueryParameter['game'] = game;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get map by ID.
         * @param {number} mapId Map ID filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mapMapIdGet(mapId: number, options: any = {}): FetchArgs {
            // verify required parameter 'mapId' is not null or undefined
            if (mapId === null || mapId === undefined) {
                throw new RequiredError('mapId','Required parameter mapId was null or undefined when calling mapMapIdGet.');
            }
            const localVarPath = `/map/{mapId}`
                .replace(`{${"mapId"}}`, encodeURIComponent(String(mapId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api-key")
					: configuration.apiKey;
                localVarHeaderParameter["api-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MapApi - functional programming interface
 * @export
 */
export const MapApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get list of maps.
         * @param {number} [game] Game ID filter
         * @param {number} [page] Page api results. Page size is 200.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mapGet(game?: number, page?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
            const localVarFetchArgs = MapApiFetchParamCreator(configuration).mapGet(game, page, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get map by ID.
         * @param {number} mapId Map ID filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mapMapIdGet(mapId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = MapApiFetchParamCreator(configuration).mapMapIdGet(mapId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MapApi - factory interface
 * @export
 */
export const MapApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get list of maps.
         * @param {number} [game] Game ID filter
         * @param {number} [page] Page api results. Page size is 200.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mapGet(game?: number, page?: number, options?: any) {
            return MapApiFp(configuration).mapGet(game, page, options)(fetch, basePath);
        },
        /**
         * Get map by ID.
         * @param {number} mapId Map ID filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mapMapIdGet(mapId: number, options?: any) {
            return MapApiFp(configuration).mapMapIdGet(mapId, options)(fetch, basePath);
        },
    };
};

/**
 * MapApi - object-oriented interface
 * @export
 * @class MapApi
 * @extends {BaseAPI}
 */
export class MapApi extends BaseAPI {
    /**
     * Get list of maps.
     * @param {number} [game] Game ID filter
     * @param {number} [page] Page api results. Page size is 200.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MapApi
     */
    public mapGet(game?: number, page?: number, options?: any) {
        return MapApiFp(this.configuration).mapGet(game, page, options)(this.fetch, this.basePath);
    }

    /**
     * Get map by ID.
     * @param {number} mapId Map ID filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MapApi
     */
    public mapMapIdGet(mapId: number, options?: any) {
        return MapApiFp(this.configuration).mapMapIdGet(mapId, options)(this.fetch, this.basePath);
    }

}

/**
 * RankApi - fetch parameter creator
 * @export
 */
export const RankApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Top ranked players, paged at 50 per page.
         * @param {number} style Style ID filter
         * @param {number} game Game ID filter
         * @param {number} [page] Page api results, Page size is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankGet(style: number, game: number, page?: number, options: any = {}): FetchArgs {
            // verify required parameter 'style' is not null or undefined
            if (style === null || style === undefined) {
                throw new RequiredError('style','Required parameter style was null or undefined when calling rankGet.');
            }
            // verify required parameter 'game' is not null or undefined
            if (game === null || game === undefined) {
                throw new RequiredError('game','Required parameter game was null or undefined when calling rankGet.');
            }
            const localVarPath = `/rank`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api-key")
					: configuration.apiKey;
                localVarHeaderParameter["api-key"] = localVarApiKeyValue;
            }

            if (style !== undefined) {
                localVarQueryParameter['style'] = style;
            }

            if (game !== undefined) {
                localVarQueryParameter['game'] = game;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get rank of user by their id.
         * @param {number} userId User ID filter
         * @param {number} style Style ID filter
         * @param {number} game Game ID filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankUserIdGet(userId: number, style: number, game: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling rankUserIdGet.');
            }
            // verify required parameter 'style' is not null or undefined
            if (style === null || style === undefined) {
                throw new RequiredError('style','Required parameter style was null or undefined when calling rankUserIdGet.');
            }
            // verify required parameter 'game' is not null or undefined
            if (game === null || game === undefined) {
                throw new RequiredError('game','Required parameter game was null or undefined when calling rankUserIdGet.');
            }
            const localVarPath = `/rank/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api-key")
					: configuration.apiKey;
                localVarHeaderParameter["api-key"] = localVarApiKeyValue;
            }

            if (style !== undefined) {
                localVarQueryParameter['style'] = style;
            }

            if (game !== undefined) {
                localVarQueryParameter['game'] = game;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RankApi - functional programming interface
 * @export
 */
export const RankApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Top ranked players, paged at 50 per page.
         * @param {number} style Style ID filter
         * @param {number} game Game ID filter
         * @param {number} [page] Page api results, Page size is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankGet(style: number, game: number, page?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Rank>> {
            const localVarFetchArgs = RankApiFetchParamCreator(configuration).rankGet(style, game, page, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get rank of user by their id.
         * @param {number} userId User ID filter
         * @param {number} style Style ID filter
         * @param {number} game Game ID filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankUserIdGet(userId: number, style: number, game: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Rank> {
            const localVarFetchArgs = RankApiFetchParamCreator(configuration).rankUserIdGet(userId, style, game, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RankApi - factory interface
 * @export
 */
export const RankApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Top ranked players, paged at 50 per page.
         * @param {number} style Style ID filter
         * @param {number} game Game ID filter
         * @param {number} [page] Page api results, Page size is 50.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankGet(style: number, game: number, page?: number, options?: any) {
            return RankApiFp(configuration).rankGet(style, game, page, options)(fetch, basePath);
        },
        /**
         * Get rank of user by their id.
         * @param {number} userId User ID filter
         * @param {number} style Style ID filter
         * @param {number} game Game ID filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rankUserIdGet(userId: number, style: number, game: number, options?: any) {
            return RankApiFp(configuration).rankUserIdGet(userId, style, game, options)(fetch, basePath);
        },
    };
};

/**
 * RankApi - object-oriented interface
 * @export
 * @class RankApi
 * @extends {BaseAPI}
 */
export class RankApi extends BaseAPI {
    /**
     * Top ranked players, paged at 50 per page.
     * @param {number} style Style ID filter
     * @param {number} game Game ID filter
     * @param {number} [page] Page api results, Page size is 50.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankApi
     */
    public rankGet(style: number, game: number, page?: number, options?: any) {
        return RankApiFp(this.configuration).rankGet(style, game, page, options)(this.fetch, this.basePath);
    }

    /**
     * Get rank of user by their id.
     * @param {number} userId User ID filter
     * @param {number} style Style ID filter
     * @param {number} game Game ID filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankApi
     */
    public rankUserIdGet(userId: number, style: number, game: number, options?: any) {
        return RankApiFp(this.configuration).rankUserIdGet(userId, style, game, options)(this.fetch, this.basePath);
    }

}

/**
 * TimeApi - fetch parameter creator
 * @export
 */
export const TimeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Time by map id. Sorted in ascending order.
         * @param {number} mapId Map ID filter
         * @param {number} [style] Style ID filter
         * @param {number} [page] Page api results. Page size is 200.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeMapMapIdGet(mapId: number, style?: number, page?: number, options: any = {}): FetchArgs {
            // verify required parameter 'mapId' is not null or undefined
            if (mapId === null || mapId === undefined) {
                throw new RequiredError('mapId','Required parameter mapId was null or undefined when calling timeMapMapIdGet.');
            }
            const localVarPath = `/time/map/{mapId}`
                .replace(`{${"mapId"}}`, encodeURIComponent(String(mapId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api-key")
					: configuration.apiKey;
                localVarHeaderParameter["api-key"] = localVarApiKeyValue;
            }

            if (style !== undefined) {
                localVarQueryParameter['style'] = style;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get WR of map.
         * @param {number} mapId Map ID filter
         * @param {number} style Style ID filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeMapMapIdWrGet(mapId: number, style: number, options: any = {}): FetchArgs {
            // verify required parameter 'mapId' is not null or undefined
            if (mapId === null || mapId === undefined) {
                throw new RequiredError('mapId','Required parameter mapId was null or undefined when calling timeMapMapIdWrGet.');
            }
            // verify required parameter 'style' is not null or undefined
            if (style === null || style === undefined) {
                throw new RequiredError('style','Required parameter style was null or undefined when calling timeMapMapIdWrGet.');
            }
            const localVarPath = `/time/map/{mapId}/wr`
                .replace(`{${"mapId"}}`, encodeURIComponent(String(mapId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api-key")
					: configuration.apiKey;
                localVarHeaderParameter["api-key"] = localVarApiKeyValue;
            }

            if (style !== undefined) {
                localVarQueryParameter['style'] = style;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 50 recent times.
         * @param {number} [date] Filter out all times before unix time stamp.
         * @param {number} [style] Style ID filter
         * @param {number} [game] Game ID filter
         * @param {number} [map] Map ID filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeRecentGet(date?: number, style?: number, game?: number, map?: number, options: any = {}): FetchArgs {
            const localVarPath = `/time/recent`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api-key")
					: configuration.apiKey;
                localVarHeaderParameter["api-key"] = localVarApiKeyValue;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (style !== undefined) {
                localVarQueryParameter['style'] = style;
            }

            if (game !== undefined) {
                localVarQueryParameter['game'] = game;
            }

            if (map !== undefined) {
                localVarQueryParameter['map'] = map;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 10 recent world records.
         * @param {number} style Style ID filter
         * @param {number} game Game ID filter
         * @param {boolean} [whitelist] Filters for only players on the whitelist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeRecentWrGet(style: number, game: number, whitelist?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'style' is not null or undefined
            if (style === null || style === undefined) {
                throw new RequiredError('style','Required parameter style was null or undefined when calling timeRecentWrGet.');
            }
            // verify required parameter 'game' is not null or undefined
            if (game === null || game === undefined) {
                throw new RequiredError('game','Required parameter game was null or undefined when calling timeRecentWrGet.');
            }
            const localVarPath = `/time/recent/wr`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api-key")
					: configuration.apiKey;
                localVarHeaderParameter["api-key"] = localVarApiKeyValue;
            }

            if (style !== undefined) {
                localVarQueryParameter['style'] = style;
            }

            if (game !== undefined) {
                localVarQueryParameter['game'] = game;
            }

            if (whitelist !== undefined) {
                localVarQueryParameter['whitelist'] = whitelist;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Time from id.
         * @param {number} timeId Time ID filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeTimeIdGet(timeId: number, options: any = {}): FetchArgs {
            // verify required parameter 'timeId' is not null or undefined
            if (timeId === null || timeId === undefined) {
                throw new RequiredError('timeId','Required parameter timeId was null or undefined when calling timeTimeIdGet.');
            }
            const localVarPath = `/time/{timeId}`
                .replace(`{${"timeId"}}`, encodeURIComponent(String(timeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api-key")
					: configuration.apiKey;
                localVarHeaderParameter["api-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Time rank from id.
         * @param {number} timeId Time ID filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeTimeIdRankGet(timeId: number, options: any = {}): FetchArgs {
            // verify required parameter 'timeId' is not null or undefined
            if (timeId === null || timeId === undefined) {
                throw new RequiredError('timeId','Required parameter timeId was null or undefined when calling timeTimeIdRankGet.');
            }
            const localVarPath = `/time/{timeId}/rank`
                .replace(`{${"timeId"}}`, encodeURIComponent(String(timeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api-key")
					: configuration.apiKey;
                localVarHeaderParameter["api-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Time by user id.
         * @param {number} userId User ID filter
         * @param {number} [map] Map ID filter
         * @param {number} [style] Style ID filter
         * @param {number} [game] Game ID filter
         * @param {number} [page] Page api results. Page size is 200.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeUserUserIdGet(userId: number, map?: number, style?: number, game?: number, page?: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling timeUserUserIdGet.');
            }
            const localVarPath = `/time/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api-key")
					: configuration.apiKey;
                localVarHeaderParameter["api-key"] = localVarApiKeyValue;
            }

            if (map !== undefined) {
                localVarQueryParameter['map'] = map;
            }

            if (style !== undefined) {
                localVarQueryParameter['style'] = style;
            }

            if (game !== undefined) {
                localVarQueryParameter['game'] = game;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * World records by user id.
         * @param {number} userId User ID filter
         * @param {number} game Game ID filter
         * @param {number} style Style ID filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeUserUserIdWrGet(userId: number, game: number, style: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling timeUserUserIdWrGet.');
            }
            // verify required parameter 'game' is not null or undefined
            if (game === null || game === undefined) {
                throw new RequiredError('game','Required parameter game was null or undefined when calling timeUserUserIdWrGet.');
            }
            // verify required parameter 'style' is not null or undefined
            if (style === null || style === undefined) {
                throw new RequiredError('style','Required parameter style was null or undefined when calling timeUserUserIdWrGet.');
            }
            const localVarPath = `/time/user/{userId}/wr`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api-key")
					: configuration.apiKey;
                localVarHeaderParameter["api-key"] = localVarApiKeyValue;
            }

            if (game !== undefined) {
                localVarQueryParameter['game'] = game;
            }

            if (style !== undefined) {
                localVarQueryParameter['style'] = style;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimeApi - functional programming interface
 * @export
 */
export const TimeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Time by map id. Sorted in ascending order.
         * @param {number} mapId Map ID filter
         * @param {number} [style] Style ID filter
         * @param {number} [page] Page api results. Page size is 200.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeMapMapIdGet(mapId: number, style?: number, page?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Time>> {
            const localVarFetchArgs = TimeApiFetchParamCreator(configuration).timeMapMapIdGet(mapId, style, page, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get WR of map.
         * @param {number} mapId Map ID filter
         * @param {number} style Style ID filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeMapMapIdWrGet(mapId: number, style: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Time> {
            const localVarFetchArgs = TimeApiFetchParamCreator(configuration).timeMapMapIdWrGet(mapId, style, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 50 recent times.
         * @param {number} [date] Filter out all times before unix time stamp.
         * @param {number} [style] Style ID filter
         * @param {number} [game] Game ID filter
         * @param {number} [map] Map ID filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeRecentGet(date?: number, style?: number, game?: number, map?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Time>> {
            const localVarFetchArgs = TimeApiFetchParamCreator(configuration).timeRecentGet(date, style, game, map, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 10 recent world records.
         * @param {number} style Style ID filter
         * @param {number} game Game ID filter
         * @param {boolean} [whitelist] Filters for only players on the whitelist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeRecentWrGet(style: number, game: number, whitelist?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Time>> {
            const localVarFetchArgs = TimeApiFetchParamCreator(configuration).timeRecentWrGet(style, game, whitelist, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Time from id.
         * @param {number} timeId Time ID filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeTimeIdGet(timeId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Time> {
            const localVarFetchArgs = TimeApiFetchParamCreator(configuration).timeTimeIdGet(timeId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Time rank from id.
         * @param {number} timeId Time ID filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeTimeIdRankGet(timeId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = TimeApiFetchParamCreator(configuration).timeTimeIdRankGet(timeId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Time by user id.
         * @param {number} userId User ID filter
         * @param {number} [map] Map ID filter
         * @param {number} [style] Style ID filter
         * @param {number} [game] Game ID filter
         * @param {number} [page] Page api results. Page size is 200.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeUserUserIdGet(userId: number, map?: number, style?: number, game?: number, page?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Time>> {
            const localVarFetchArgs = TimeApiFetchParamCreator(configuration).timeUserUserIdGet(userId, map, style, game, page, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * World records by user id.
         * @param {number} userId User ID filter
         * @param {number} game Game ID filter
         * @param {number} style Style ID filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeUserUserIdWrGet(userId: number, game: number, style: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Time>> {
            const localVarFetchArgs = TimeApiFetchParamCreator(configuration).timeUserUserIdWrGet(userId, game, style, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TimeApi - factory interface
 * @export
 */
export const TimeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Time by map id. Sorted in ascending order.
         * @param {number} mapId Map ID filter
         * @param {number} [style] Style ID filter
         * @param {number} [page] Page api results. Page size is 200.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeMapMapIdGet(mapId: number, style?: number, page?: number, options?: any) {
            return TimeApiFp(configuration).timeMapMapIdGet(mapId, style, page, options)(fetch, basePath);
        },
        /**
         * Get WR of map.
         * @param {number} mapId Map ID filter
         * @param {number} style Style ID filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeMapMapIdWrGet(mapId: number, style: number, options?: any) {
            return TimeApiFp(configuration).timeMapMapIdWrGet(mapId, style, options)(fetch, basePath);
        },
        /**
         * 50 recent times.
         * @param {number} [date] Filter out all times before unix time stamp.
         * @param {number} [style] Style ID filter
         * @param {number} [game] Game ID filter
         * @param {number} [map] Map ID filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeRecentGet(date?: number, style?: number, game?: number, map?: number, options?: any) {
            return TimeApiFp(configuration).timeRecentGet(date, style, game, map, options)(fetch, basePath);
        },
        /**
         * 10 recent world records.
         * @param {number} style Style ID filter
         * @param {number} game Game ID filter
         * @param {boolean} [whitelist] Filters for only players on the whitelist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeRecentWrGet(style: number, game: number, whitelist?: boolean, options?: any) {
            return TimeApiFp(configuration).timeRecentWrGet(style, game, whitelist, options)(fetch, basePath);
        },
        /**
         * Time from id.
         * @param {number} timeId Time ID filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeTimeIdGet(timeId: number, options?: any) {
            return TimeApiFp(configuration).timeTimeIdGet(timeId, options)(fetch, basePath);
        },
        /**
         * Time rank from id.
         * @param {number} timeId Time ID filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeTimeIdRankGet(timeId: number, options?: any) {
            return TimeApiFp(configuration).timeTimeIdRankGet(timeId, options)(fetch, basePath);
        },
        /**
         * Time by user id.
         * @param {number} userId User ID filter
         * @param {number} [map] Map ID filter
         * @param {number} [style] Style ID filter
         * @param {number} [game] Game ID filter
         * @param {number} [page] Page api results. Page size is 200.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeUserUserIdGet(userId: number, map?: number, style?: number, game?: number, page?: number, options?: any) {
            return TimeApiFp(configuration).timeUserUserIdGet(userId, map, style, game, page, options)(fetch, basePath);
        },
        /**
         * World records by user id.
         * @param {number} userId User ID filter
         * @param {number} game Game ID filter
         * @param {number} style Style ID filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeUserUserIdWrGet(userId: number, game: number, style: number, options?: any) {
            return TimeApiFp(configuration).timeUserUserIdWrGet(userId, game, style, options)(fetch, basePath);
        },
    };
};

/**
 * TimeApi - object-oriented interface
 * @export
 * @class TimeApi
 * @extends {BaseAPI}
 */
export class TimeApi extends BaseAPI {
    /**
     * Time by map id. Sorted in ascending order.
     * @param {number} mapId Map ID filter
     * @param {number} [style] Style ID filter
     * @param {number} [page] Page api results. Page size is 200.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeApi
     */
    public timeMapMapIdGet(mapId: number, style?: number, page?: number, options?: any) {
        return TimeApiFp(this.configuration).timeMapMapIdGet(mapId, style, page, options)(this.fetch, this.basePath);
    }

    /**
     * Get WR of map.
     * @param {number} mapId Map ID filter
     * @param {number} style Style ID filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeApi
     */
    public timeMapMapIdWrGet(mapId: number, style: number, options?: any) {
        return TimeApiFp(this.configuration).timeMapMapIdWrGet(mapId, style, options)(this.fetch, this.basePath);
    }

    /**
     * 50 recent times.
     * @param {number} [date] Filter out all times before unix time stamp.
     * @param {number} [style] Style ID filter
     * @param {number} [game] Game ID filter
     * @param {number} [map] Map ID filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeApi
     */
    public timeRecentGet(date?: number, style?: number, game?: number, map?: number, options?: any) {
        return TimeApiFp(this.configuration).timeRecentGet(date, style, game, map, options)(this.fetch, this.basePath);
    }

    /**
     * 10 recent world records.
     * @param {number} style Style ID filter
     * @param {number} game Game ID filter
     * @param {boolean} [whitelist] Filters for only players on the whitelist
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeApi
     */
    public timeRecentWrGet(style: number, game: number, whitelist?: boolean, options?: any) {
        return TimeApiFp(this.configuration).timeRecentWrGet(style, game, whitelist, options)(this.fetch, this.basePath);
    }

    /**
     * Time from id.
     * @param {number} timeId Time ID filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeApi
     */
    public timeTimeIdGet(timeId: number, options?: any) {
        return TimeApiFp(this.configuration).timeTimeIdGet(timeId, options)(this.fetch, this.basePath);
    }

    /**
     * Time rank from id.
     * @param {number} timeId Time ID filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeApi
     */
    public timeTimeIdRankGet(timeId: number, options?: any) {
        return TimeApiFp(this.configuration).timeTimeIdRankGet(timeId, options)(this.fetch, this.basePath);
    }

    /**
     * Time by user id.
     * @param {number} userId User ID filter
     * @param {number} [map] Map ID filter
     * @param {number} [style] Style ID filter
     * @param {number} [game] Game ID filter
     * @param {number} [page] Page api results. Page size is 200.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeApi
     */
    public timeUserUserIdGet(userId: number, map?: number, style?: number, game?: number, page?: number, options?: any) {
        return TimeApiFp(this.configuration).timeUserUserIdGet(userId, map, style, game, page, options)(this.fetch, this.basePath);
    }

    /**
     * World records by user id.
     * @param {number} userId User ID filter
     * @param {number} game Game ID filter
     * @param {number} style Style ID filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeApi
     */
    public timeUserUserIdWrGet(userId: number, game: number, style: number, options?: any) {
        return TimeApiFp(this.configuration).timeUserUserIdWrGet(userId, game, style, options)(this.fetch, this.basePath);
    }

}

/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User from id.
         * @param {number} userId User ID filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUserIdGet(userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling userUserIdGet.');
            }
            const localVarPath = `/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api-key")
					: configuration.apiKey;
                localVarHeaderParameter["api-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * User from id.
         * @param {number} userId User ID filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUserIdGet(userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userUserIdGet(userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * User from id.
         * @param {number} userId User ID filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUserIdGet(userId: number, options?: any) {
            return UserApiFp(configuration).userUserIdGet(userId, options)(fetch, basePath);
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * User from id.
     * @param {number} userId User ID filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userUserIdGet(userId: number, options?: any) {
        return UserApiFp(this.configuration).userUserIdGet(userId, options)(this.fetch, this.basePath);
    }

}

